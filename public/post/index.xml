<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Dorin Fodor</title>
    <link>https://fodor.org/post/</link>
    <description>Recent content in Posts on Dorin Fodor</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2008–2019</copyright>
    <lastBuildDate>Fri, 20 Dec 2019 21:45:00 +0000</lastBuildDate>
    
	<atom:link href="https://fodor.org/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go: counting semaphores</title>
      <link>https://fodor.org/blog/go-counting-semaphores/</link>
      <pubDate>Fri, 20 Dec 2019 21:45:00 +0000</pubDate>
      
      <guid>https://fodor.org/blog/go-counting-semaphores/</guid>
      <description>Goroutines One of the main features of the Go programming languages is the goroutine. Executing a function as a goroutine lets us run things in parallel which can greatly improve the performance of our application. But you can take parallelism only so far before it actually starts making things slower.
Unlimited parallelism Your code might be calling a function called doInParallel() as a goroutine in this fashion:
func main() { wg := sync.</description>
    </item>
    
  </channel>
</rss>